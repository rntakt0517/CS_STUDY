## **프로세스**

- **정의**: 프로세스는 실행 중인 프로그램의 인스턴스를 의미함.
- **특징**:
  - 독립된 메모리 공간을 가짐.
  - 운영체제에서 실행 중인 애플리케이션이나 서비스를 나타냄.
  - 커널은 각 프로세스에 고유한 프로세스 식별자(PID)를 부여함.
  - 프로세스는 자신만의 주소 공간, 파일 디스크립터 테이블, 스택, 데이터 세그먼트를 가짐.
- **생성과 종료**:
  - 새로운 프로세스는 `fork()` 시스템 호출로 생성되며, 부모 프로세스의 메모리 공간을 복사하여 자식 프로세스를 만듦.
  - `exec()` 시스템 호출을 통해 새로운 프로그램으로 교체될 수 있음.
  - 프로세스는 `exit()` 시스템 호출을 통해 종료됨. 부모 프로세스는 `wait()`를 통해 자식 프로세스의 종료 상태를 수집함.
- **상호작용**:
  - 프로세스 간에는 메모리 공간이 격리되어 있으므로, IPC(Inter-Process Communication) 메커니즘을 통해 상호작용함. 파이프, 메시지 큐, 공유 메모리 등이 사용됨.

---

## **스레드**

- **정의**: 스레드는 프로세스 내에서 실행되는 작업의 단위를 의미함.
- **특징**:
  - 하나의 프로세스 내에서 여러 스레드가 실행될 수 있으며, 이들 스레드는 동일한 메모리 공간을 공유함.
  - 각 스레드는 자체 레지스터, 스택, 프로그램 카운터를 가짐.
  - 스레드는 CPU 스케줄링의 기본 단위로, 여러 스레드가 병렬로 실행되며 프로세스의 효율성을 높임.
  - 동일한 프로세스 내에서 다른 스레드와 데이터를 쉽게 공유할 수 있으므로, 멀티스레딩을 통해 병렬 처리가 가능함.
- **생성과 종료**:
  - 스레드는 `pthread_create()`와 같은 함수로 생성되며, 프로세스 내에서 독립적으로 실행됨.
  - 스레드는 `pthread_exit()` 또는 리턴 문을 통해 종료될 수 있음.
- **상호작용**:
  - 스레드 간 상호작용은 동일한 메모리 공간을 공유하므로, 공유 데이터의 동기화 문제가 발생할 수 있음. 이를 방지하기 위해 뮤텍스, 세마포어 등의 동기화 메커니즘이 사용됨.

---

## **태스크(Task)**

- **정의**: 리눅스에서 프로세스와 스레드를 통칭하는 용어로, 태스크는 CPU에서 실행될 수 있는 작업의 단위를 의미함.
- **특징**:
  - 리눅스 커널은 프로세스와 스레드를 모두 태스크로 취급함.
  - 커널 내부에서는 프로세스와 스레드 모두 `task_struct`라는 동일한 데이터 구조로 관리됨.
  - `task_struct`는 프로세스 ID, 부모 프로세스, 메모리 관리 정보, 스케줄링 정보 등을 포함함.
  - 실제 CPU 스케줄링은 프로세스가 아닌 스레드 단위로 이루어짐. 이는 CPU 자원을 효율적으로 사용하기 위함임.
  - 멀티스레드 환경에서 여러 스레드가 동일한 프로세스 내에서 실행될 때, 각 스레드는 개별적으로 CPU에 스케줄링됨.
- **스케줄링**:
  - 리눅스 커널은 CFS(Completely Fair Scheduler)와 같은 스케줄러를 사용하여 태스크를 관리함.
  - 각 태스크는 우선순위와 실행 시간을 기반으로 CPU 시간을 할당받음.
  - 태스크가 I/O 작업을 기다리는 동안, CPU는 다른 태스크를 실행하여 자원의 낭비를 줄임.

---

## CPU 스케줄링이란?

- 정의 : 운영체제가 프로세스들에게 CPU 자원을 공정하고 합리적으로 배분하는 것을 의미. 이 과정은 컴퓨터의 전체 성능과 직결.

- **중요성**: CPU 자원 분배가 적절하지 않으면 필요한 프로세스가 실행되지 않거나, 불필요한 프로세스만 계속 실행될 수 있음.

## 공정한 CPU 스케줄링이란?

- **단순 차례 배분**: CPU를 사용하고 싶어하는 프로세스들이 차례대로 CPU를 사용하는 방법.
  - **문제점**: 프로세스마다 우선순위가 다르기 때문에 공정하지 않을 수 있음.
  - **예시**: 입출력 작업이 많은 프로세스와 CPU 작업이 많은 프로세스의 차이.

## 프로세스 우선순위

- **입출력 집중 프로세스 (IO 바운드)**: 입출력 작업이 많은 프로세스는 우선순위가 높음.
- **CPU 집중 프로세스 (CPU 바운드)**: CPU 작업이 많은 프로세스는 상대적으로 우선순위가 낮음.

## 스케줄링 큐

- **스케줄링 큐**: 자원을 요청하는 프로세스들이 줄을 서는 구조.
- **구성**: CPU 스케줄링 큐, 하드디스크 스케줄링 큐 등.
- **자료 구조**: 원래 큐는 선입선출(FIFO) 구조지만, 스케줄링 큐는 반드시 선입선출이 아님.

## 준비 큐와 대기 큐

- **준비 큐**: CPU를 사용하기를 기다리는 프로세스들이 대기하는 큐.
- **대기 큐**: 입출력 작업을 기다리는 프로세스들이 대기하는 큐.

## 스케줄링 흐름

1. **준비 상태**: 프로세스가 CPU 자원을 기다림.
2. **실행 상태**: CPU 자원을 할당받아 실행.
3. **대기 상태**: 입출력 작업 등을 기다리며 대기.
4. **상태 변화**: 대기 상태에서 작업 완료 시 준비 상태로 돌아옴.

## 선점형 vs 비선점형 스케줄링

- **선점형 스케줄링 (Preemptive Scheduling)**:
  
  - **정의**: CPU를 사용 중인 프로세스에서 자원을 빼앗아 더 우선순위가 높은 프로세스에게 할당하는 방식.
  - **장점**: 자원 독점을 방지하고 공평한 배분 가능.
  - **단점**: 문맥 교환 오버헤드 발생.

- **비선점형 스케줄링 (Non-Preemptive Scheduling)**:
  
  - **정의**: 프로세스가 CPU를 점유하고 있을 때, 해당 프로세스가 종료되거나 대기 상태에 접어들 때까지 다른 프로세스가 CPU를 사용할 수 없는 방식.
  - **장점**: 문맥 교환 오버헤드가 적음.
  - **단점**: 공평한 자원 배분이 어려울 수 있음.

---

# 스케줄링 알고리즘

### 1. 선입선처리 스케줄링 (FCFS)

- **설명**: FCFS(First-Come, First-Served) 스케줄링은 준비 큐에 삽입된 순서대로 처리하는 방식. 비선점형 방식으로, 먼저 CPU를 요청한 프로세스부터 CPU를 할당받음.
- **단점**: 긴 프로세스가 먼저 실행되면, 뒤에 있는 프로세스들의 대기 시간이 길어질 수 있음. 이 현상을 '호위 효과'라고 함.
- **예시**: 실행 시간이 17, 5, 2인 프로세스 A, B, C가 순서대로 준비 큐에 삽입된 경우, 프로세스 B와 C는 A가 처리될 때까지 기다려야 하므로 대기 시간이 길어짐.

### 2. 최단 작업 시간 우선 스케줄링 (SJF)

- **설명**: SJF(Shortest Job First) 스케줄링은 CPU 사용 시간이 짧은 프로세스부터 처리하는 방식. 최단 작업 시간 우선 스케줄링은 비선점형으로 구현.
- **장점**: 대기 시간을 줄일 수 있음.
- **단점**: 실행 시간이 짧은 프로세스가 먼저 실행되지만, 실행 시간이 긴 프로세스는 대기 시간이 길어질 수 있음.

### 3. 라운드 로빈 스케줄링 (RR)

- **설명**: RR(Round Robin) 스케줄링은 선입선처리 스케줄링에 타임 슬라이스를 추가한 방식. 각 프로세스는 정해진 시간만큼만 CPU를 사용할 수 있으며, 타임 슬라이스가 지나면 문맥 교환이 이루어짐.
- **예시**: 타임 슬라이스가 4인 경우, 프로세스 A는 4만큼 실행 후 문맥 교환, 프로세스 B는 3만큼 실행 후 문맥 교환, 프로세스 C는 타임 슬라이스만큼 실행 후 문맥 교환이 이루어짐.
- **주의사항**: 타임 슬라이스의 크기가 너무 크면 선입선처리와 비슷해지고, 너무 작으면 문맥 교환 오버헤드가 커질 수 있음.

### 4. 최소 잔여 시간 우선 스케줄링 (SRT)

- **설명**: SRT(Shortest Remaining Time) 스케줄링은 정해진 시간만큼 CPU를 사용하되, 남은 작업 시간이 가장 적은 프로세스를 선택하는 방식. 최단 작업 시간 우선 스케줄링과 라운드 로빈 스케줄링의 결합된 형태.
- **장점**: 남은 작업 시간이 짧은 프로세스를 우선 처리하여 대기 시간을 줄일 수 있음.

### 5. 우선순위 스케줄링

- **설명**: 우선순위 스케줄링은 각 프로세스에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 방식.
- **단점**: 우선순위가 낮은 프로세스는 무한히 대기할 수 있으며, 이를 '스타베이션' 또는 '기아 현상'이라고 함.
- **해결책**: 에이징 기법을 사용하여 우선순위가 낮은 프로세스의 우선순위를 점진적으로 높여 기아 현상을 방지할 수 있음.

### 6. 다단계 큐 스케줄링 (Multilevel Queue Scheduling)

- **설명**: 다단계 큐 스케줄링은 우선순위별로 여러 개의 큐를 사용하여 프로세스를 관리하는 방식. 각 큐는 서로 다른 스케줄링 방법을 사용할 수 있음.
- **장점**: 프로세스의 유형에 따라 적절한 스케줄링 방식 적용 가능.
- **단점**: 프로세스가 큐 간에 이동할 수 없으므로 기아 현상이 발생할 수 있음.

### 7. 다단계 피드백 큐 스케줄링 (Multilevel Feedback Queue Scheduling)

- **설명**: 다단계 피드백 큐 스케줄링은 다단계 큐 스케줄링의 발전된 형태로, 큐 간의 이동이 가능. 프로세스는 초기에는 가장 높은 우선순위 큐에 삽입되며, CPU를 더 많이 사용하는 프로세스는 우선순위가 낮아지게 됨.
- **장점**: CPU 집중 프로세스와 입출력 집중 프로세스 효과적으로 관리 가능 기아 현상을 방지하기 위해 에이징 기법 적용 가능.
